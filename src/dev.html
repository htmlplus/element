<html>
  <body>
    <script type="module">
      // node_modules/umap/esm/index.js
      var esm_default = (_) => ({
        get: (key) => _.get(key),
        set: (key, value) => (_.set(key, value), value)
      });

      // node_modules/uparser/esm/index.js
      var attr = /([^\s\\>"'=]+)\s*=\s*(['"]?)$/;
      var empty = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;
      var node = /<[a-z][^>]+$/i;
      var notNode = />[^<>]*$/;
      var selfClosing = /<([a-z]+[a-z0-9:._-]*)([^>]*?)(\/>)/ig;
      var trimEnd = /\s+$/;
      var isNode = (template, i) => 0 < i-- && (node.test(template[i]) || !notNode.test(template[i]) && isNode(template, i));
      var regular = (original, name, extra) => empty.test(name) ? original : `<${name}${extra.replace(trimEnd, "")}></${name}>`;
      var esm_default2 = (template, prefix2, svg2) => {
        const text2 = [];
        const { length } = template;
        for (let i = 1; i < length; i++) {
          const chunk = template[i - 1];
          text2.push(attr.test(chunk) && isNode(template, i) ? chunk.replace(attr, (_, $1, $2) => `${prefix2}${i - 1}=${$2 || '"'}${$1}${$2 ? "" : '"'}`) : `${chunk}<!--${prefix2}${i - 1}-->`);
        }
        text2.push(template[length - 1]);
        const output = text2.join("").trim();
        return svg2 ? output : output.replace(selfClosing, regular);
      };

      // node_modules/uarray/esm/index.js
      var { isArray } = Array;
      var { indexOf, slice } = [];

      // node_modules/uwire/esm/index.js
      var ELEMENT_NODE = 1;
      var nodeType = 111;
      var remove = ({ firstChild, lastChild }) => {
        const range = document.createRange();
        range.setStartAfter(firstChild);
        range.setEndAfter(lastChild);
        range.deleteContents();
        return firstChild;
      };
      var diffable = (node2, operation) => node2.nodeType === nodeType ? 1 / operation < 0 ? operation ? remove(node2) : node2.lastChild : operation ? node2.valueOf() : node2.firstChild : node2;
      var persistent = (fragment) => {
        const { childNodes } = fragment;
        const { length } = childNodes;
        if (length < 2)
          return length ? childNodes[0] : fragment;
        const nodes = slice.call(childNodes, 0);
        const firstChild = nodes[0];
        const lastChild = nodes[length - 1];
        return {
          ELEMENT_NODE,
          nodeType,
          firstChild,
          lastChild,
          valueOf() {
            if (childNodes.length !== length) {
              let i = 0;
              while (i < length)
                fragment.appendChild(nodes[i++]);
            }
            return fragment;
          }
        };
      };

      // node_modules/udomdiff/esm/index.js
      var esm_default3 = (parentNode, a, b, get, before) => {
        const bLength = b.length;
        let aEnd = a.length;
        let bEnd = bLength;
        let aStart = 0;
        let bStart = 0;
        let map = null;
        while (aStart < aEnd || bStart < bEnd) {
          if (aEnd === aStart) {
            const node2 = bEnd < bLength ? bStart ? get(b[bStart - 1], -0).nextSibling : get(b[bEnd - bStart], 0) : before;
            while (bStart < bEnd)
              parentNode.insertBefore(get(b[bStart++], 1), node2);
          } else if (bEnd === bStart) {
            while (aStart < aEnd) {
              if (!map || !map.has(a[aStart]))
                parentNode.removeChild(get(a[aStart], -1));
              aStart++;
            }
          } else if (a[aStart] === b[bStart]) {
            aStart++;
            bStart++;
          } else if (a[aEnd - 1] === b[bEnd - 1]) {
            aEnd--;
            bEnd--;
          } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
            const node2 = get(a[--aEnd], -1).nextSibling;
            parentNode.insertBefore(get(b[bStart++], 1), get(a[aStart++], -1).nextSibling);
            parentNode.insertBefore(get(b[--bEnd], 1), node2);
            a[aEnd] = b[bEnd];
          } else {
            if (!map) {
              map = /* @__PURE__ */ new Map();
              let i = bStart;
              while (i < bEnd)
                map.set(b[i], i++);
            }
            if (map.has(a[aStart])) {
              const index = map.get(a[aStart]);
              if (bStart < index && index < bEnd) {
                let i = aStart;
                let sequence = 1;
                while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence)
                  sequence++;
                if (sequence > index - bStart) {
                  const node2 = get(a[aStart], 0);
                  while (bStart < index)
                    parentNode.insertBefore(get(b[bStart++], 1), node2);
                } else {
                  parentNode.replaceChild(get(b[bStart++], 1), get(a[aStart++], -1));
                }
              } else
                aStart++;
            } else
              parentNode.removeChild(get(a[aStart++], -1));
          }
        }
        return b;
      };

      // node_modules/uhandlers/esm/index.js
      var aria = (node2) => (values) => {
        for (const key in values) {
          const name = key === "role" ? key : `aria-${key}`;
          const value = values[key];
          if (value == null)
            node2.removeAttribute(name);
          else
            node2.setAttribute(name, value);
        }
      };
      var attribute = (node2, name) => {
        let oldValue, orphan = true;
        const attributeNode = document.createAttributeNS(null, name);
        return (newValue) => {
          if (oldValue !== newValue) {
            oldValue = newValue;
            if (oldValue == null) {
              if (!orphan) {
                node2.removeAttributeNode(attributeNode);
                orphan = true;
              }
            } else {
              attributeNode.value = newValue;
              if (orphan) {
                node2.setAttributeNodeNS(attributeNode);
                orphan = false;
              }
            }
          }
        };
      };
      var boolean = (node2, key, oldValue) => (newValue) => {
        if (oldValue !== !!newValue) {
          if (oldValue = !!newValue)
            node2.setAttribute(key, "");
          else
            node2.removeAttribute(key);
        }
      };
      var data = ({ dataset }) => (values) => {
        for (const key in values) {
          const value = values[key];
          if (value == null)
            delete dataset[key];
          else
            dataset[key] = value;
        }
      };
      var event = (node2, name) => {
        let oldValue, type = name.slice(2);
        if (!(name in node2) && name.toLowerCase() in node2)
          type = type.toLowerCase();
        return (newValue) => {
          const info = isArray(newValue) ? newValue : [newValue, false];
          if (oldValue !== info[0]) {
            if (oldValue)
              node2.removeEventListener(type, oldValue, info);
            if (oldValue = info[0])
              node2.addEventListener(type, oldValue, info);
          }
        };
      };
      var ref = (node2) => {
        let oldValue;
        return (value) => {
          if (oldValue !== value) {
            oldValue = value;
            if (typeof value === "function")
              value(node2);
            else
              value.current = node2;
          }
        };
      };
      var setter = (node2, key) => key === "dataset" ? data(node2) : (value) => {
        node2[key] = value;
      };
      var text = (node2) => {
        let oldValue;
        return (newValue) => {
          if (oldValue != newValue) {
            oldValue = newValue;
            node2.textContent = newValue == null ? "" : newValue;
          }
        };
      };

      // node_modules/uhtml/esm/handlers.js
      var reducePath = ({ childNodes }, i) => childNodes[i];
      var diff = (comment, oldNodes, newNodes) => esm_default3(comment.parentNode, oldNodes, newNodes, diffable, comment);
      var handleAnything = (comment) => {
        let oldValue, text2, nodes = [];
        const anyContent = (newValue) => {
          switch (typeof newValue) {
            case "string":
            case "number":
            case "boolean":
              if (oldValue !== newValue) {
                oldValue = newValue;
                if (!text2)
                  text2 = document.createTextNode("");
                text2.data = newValue;
                nodes = diff(comment, nodes, [text2]);
              }
              break;
            case "object":
            case "undefined":
              if (newValue == null) {
                if (oldValue != newValue) {
                  oldValue = newValue;
                  nodes = diff(comment, nodes, []);
                }
                break;
              }
              if (isArray(newValue)) {
                oldValue = newValue;
                if (newValue.length === 0)
                  nodes = diff(comment, nodes, []);
                else if (typeof newValue[0] === "object")
                  nodes = diff(comment, nodes, newValue);
                else
                  anyContent(String(newValue));
                break;
              }
              if (oldValue !== newValue && "ELEMENT_NODE" in newValue) {
                oldValue = newValue;
                nodes = diff(comment, nodes, newValue.nodeType === 11 ? slice.call(newValue.childNodes) : [newValue]);
              }
              break;
            case "function":
              anyContent(newValue(comment));
              break;
          }
        };
        return anyContent;
      };
      var handleAttribute = (node2, name) => {
        switch (name[0]) {
          case "?":
            return boolean(node2, name.slice(1), false);
          case ".":
            return setter(node2, name.slice(1));
          case "@":
            return event(node2, "on" + name.slice(1));
          case "o":
            if (name=== "n")
              return event(node2, name);
        }
        switch (name) {
          case "ref":
            return ref(node2);
          case "aria":
            return aria(node2);
        }
        return attribute(node2, name);
      };
      function handlers(options) {
        const { type, path } = options;
        const node2 = path.reduceRight(reducePath, this);
        return type === "node" ? handleAnything(node2) : type === "attr" ? handleAttribute(node2, options.name) : text(node2);
      }

      // node_modules/@ungap/create-content/esm/index.js
      var createContent = function(document2) {
        "use strict";
        var FRAGMENT = "fragment";
        var TEMPLATE = "template";
        var HAS_CONTENT = "content" in create2(TEMPLATE);
        var createHTML = HAS_CONTENT ? function(html2) {
          var template = create2(TEMPLATE);
          template.innerHTML = html2;
          return template.content;
        } : function(html2) {
          var content = create2(FRAGMENT);
          var template = create2(TEMPLATE);
          var childNodes = null;
          if (/^[^\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html2)) {
            var selector = RegExp.$1;
            template.innerHTML = "<table>" + html2 + "</table>";
            childNodes = template.querySelectorAll(selector);
          } else {
            template.innerHTML = html2;
            childNodes = template.childNodes;
          }
          append(content, childNodes);
          return content;
        };
        return function createContent2(markup, type) {
          return (type === "svg" ? createSVG : createHTML)(markup);
        };
        function append(root, childNodes) {
          var length = childNodes.length;
          while (length--)
            root.appendChild(childNodes[0]);
        }
        function create2(element) {
          return element === FRAGMENT ? document2.createDocumentFragment() : document2.createElementNS("http://www.w3.org/1999/xhtml", element);
        }
        function createSVG(svg2) {
          var content = create2(FRAGMENT);
          var template = create2("div");
          template.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg">' + svg2 + "</svg>";
          append(content, template.firstChild.childNodes);
          return content;
        }
      }(document);
      var esm_default4 = createContent;

      // node_modules/uhtml/esm/node.js
      var isImportNodeLengthWrong = document.importNode.length != 1;
      var createFragment = isImportNodeLengthWrong ? (text2, type, normalize) => document.importNode(esm_default4(text2, type, normalize), true) : esm_default4;
      var createWalker = isImportNodeLengthWrong ? (fragment) => document.createTreeWalker(fragment, 1 | 128, null, false) : (fragment) => document.createTreeWalker(fragment, 1 | 128);

      // node_modules/uhtml/esm/rabbit.js
      var createPath = (node2) => {
        const path = [];
        let { parentNode } = node2;
        while (parentNode) {
          path.push(indexOf.call(parentNode.childNodes, node2));
          node2 = parentNode;
          parentNode = node2.parentNode;
        }
        return path;
      };
      var prefix = "is\xB5";
      var cache = esm_default(new WeakMap());
      var textOnly = /^(?:plaintext|script|style|textarea|title|xmp)$/i;
      var createCache = () => ({
        stack: [],
        entry: null,
        wire: null
      });
      var createEntry = (type, template) => {
        const { content, updates } = mapUpdates(type, template);
        return { type, template, content, updates, wire: null };
      };
      var mapTemplate = (type, template) => {
        const text2 = esm_default2(template, prefix, type === "svg");
        const content = createFragment(text2, type);
        const tw = createWalker(content);
        const nodes = [];
        const length = template.length - 1;
        let i = 0;
        let search = `${prefix}${i}`;
        while (i < length) {
          const node2 = tw.nextNode();
          if (!node2)
            throw `bad template: ${text2}`;
          if (node2.nodeType === 8) {
            if (node2.data === search) {
              nodes.push({ type: "node", path: createPath(node2) });
              search = `${prefix}${++i}`;
            }
          } else {
            while (node2.hasAttribute(search)) {
              nodes.push({
                type: "attr",
                path: createPath(node2),
                name: node2.getAttribute(search)
              });
              node2.removeAttribute(search);
              search = `${prefix}${++i}`;
            }
            if (textOnly.test(node2.tagName) && node2.textContent.trim() === `<!--${search}-->`) {
              node2.textContent = "";
              nodes.push({ type: "text", path: createPath(node2) });
              search = `${prefix}${++i}`;
            }
          }
        }
        return { content, nodes };
      };
      var mapUpdates = (type, template) => {
        const { content, nodes } = cache.get(template) || cache.set(template, mapTemplate(type, template));
        const fragment = document.importNode(content, true);
        const updates = nodes.map(handlers, fragment);
        return { content: fragment, updates };
      };
      var unroll = (info, { type, template, values }) => {
        const { length } = values;
        unrollValues(info, values, length);
        let { entry } = info;
        if (!entry || (entry.template !== template || entry.type !== type))
          info.entry = entry = createEntry(type, template);
        const { content, updates, wire } = entry;
        for (let i = 0; i < length; i++)
          updates[i](values[i]);
        return wire || (entry.wire = persistent(content));
      };
      var unrollValues = ({ stack }, values, length) => {
        for (let i = 0; i < length; i++) {
          const hole = values[i];
          if (hole instanceof Hole)
            values[i] = unroll(stack[i] || (stack[i] = createCache()), hole);
          else if (isArray(hole))
            unrollValues(stack[i] || (stack[i] = createCache()), hole, hole.length);
          else
            stack[i] = null;
        }
        if (length < stack.length)
          stack.splice(length);
      };
      function Hole(type, template, values) {
        this.type = type;
        this.template = template;
        this.values = values;
      }

      // node_modules/uhtml/esm/index.js
      var { create, defineProperties } = Object;
      var tag = (type) => {
        const keyed = esm_default(new WeakMap());
        const fixed = (cache3) => (template, ...values) => unroll(cache3, { type, template, values });
        return defineProperties((template, ...values) => new Hole(type, template, values), {
          for: {
            value(ref2, id) {
              const memo = keyed.get(ref2) || keyed.set(ref2, create(null));
              return memo[id] || (memo[id] = fixed(createCache()));
            }
          },
          node: {
            value: (template, ...values) => unroll(createCache(), { type, template, values }).valueOf()
          }
        });
      };
      var cache2 = esm_default(new WeakMap());
      var render = (where, what) => {
        const hole = typeof what === "function" ? what() : what;
        const info = cache2.get(where) || cache2.set(where, createCache());
        const wire = hole instanceof Hole ? unroll(info, hole) : hole;
        if (wire !== info.wire) {
          info.wire = wire;
          where.textContent = "";
          where.appendChild(wire.valueOf());
        }
        return where;
      };
      var html = tag("html");
      var svg = tag("svg");

      // dist/configs/constants.js
      var TOKEN_API = "$api";
      var TOKEN_API_HOST = "host";
      var TOKEN_API_PROPERTY = "property";
      var TOKEN_API_READY = "ready";
      var TOKEN_API_STATE = "state";
      var TOKEN_LIFECYCLE_MOUNT = "connectedCallback";
      var TOKEN_LIFECYCLE_UNMOUNT = "disconnectedCallback";
      var TOKEN_LIFECYCLE_READY = "readyCallback";
      var TOKEN_METHOD_RENDER = "render";
      var TOKEN_STATIC_MEMBERS = "members";
      var TOKEN_STATIC_STYLES = "styles";
      var TYPE_BOOLEAN = "boolean";
      var TYPE_FUNCTION = "method";
      var TYPE_NUMBER = "number";

      // dist/utils/is-server.js
      var isServer = () => !(typeof window != "undefined" && window.document);

      // dist/utils/get-event-name.js
      var getEventName = (input) => {
        if (!input)
          return input;
        return input.substr(2).toLowerCase();
      };

      // dist/utils/is-event.js
      var isEvent = (input) => {
        if (!input)
          return false;
        return !!input.match(/on[A-Z]\w+/g);
      };

      // dist/utils/to-kebab-case.js
      var toKebabCase = (input) => {
        if (!input)
          return input;
        return input.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/\s+/g, "-").toLowerCase();
      };

      // dist/utils/update-attribute.js
      var updateAttribute = (node2, key, value) => {
        key = toKebabCase(key);
        if (value === void 0) {
          node2.removeAttribute(key);
        } else if (value === null) {
          node2.removeAttribute(key);
        } else if (value === false) {
          node2.removeAttribute(key);
        } else if (value === true) {
          node2.setAttribute(key, "");
        } else {
          node2.setAttribute(key, value);
        }
      };

      // dist/utils/sync.js
      var sync = (node2, prev) => (next = {}) => {
        const prevClass = (prev.class || "").split(" ");
        const nextClass = (next.class || "").split(" ");
        const newClass = (node2.className || "").split(" ").filter((key) => !prevClass.includes(key) && !nextClass.includes(key)).concat(nextClass).filter((key) => key).join(" ");
        updateAttribute(node2, "class", newClass || void 0);
        if (prev.style || next.style)
          node2.setAttribute("style", next.style || "");
        for (const key in prev) {
          const value = prev[key];
          if (!isEvent(key))
            continue;
          const name = getEventName(key);
          node2.removeEventListener(name, value);
        }
        for (const key in next) {
          const value = next[key];
          if (["class", "style"].includes(key))
            continue;
          if (isEvent(key)) {
            const name = getEventName(key);
            node2.addEventListener(name, value);
            continue;
          }
          updateAttribute(node2, key, value);
        }
        prev = Object.assign({}, next);
      };

      // dist/utils/to-boolean.js
      var toBoolean = (input) => {
        if (input === "")
          return true;
        if (input === "true")
          return true;
        if (input === true)
          return true;
        if (input === "false")
          return false;
        if (input === false)
          return false;
        return input;
      };

      // dist/plugins/uhtml/utils.js
      var define = (name, Class) => {
        if (isServer())
          return;
        customElements.define(name, Class);
      };
      var proxy = (Class) => {
        if (isServer())
          return class {
          };
        let instance, update;
        const members = Class[TOKEN_STATIC_MEMBERS] || [];
        const styles = Class[TOKEN_STATIC_STYLES];
        const getValue = (key, value) => {
          const [, type] = members.find((property) => property[0] == key);
          switch (type) {
            case TYPE_BOOLEAN:
              return toBoolean(value);
            case TYPE_NUMBER:
              return parseFloat(value);
            default:
              return value;
          }
        };
        return class extends HTMLElement {
          constructor() {
            super();
            instance = new Class();
            instance[TOKEN_API] = instance[TOKEN_API] || {};
            instance[TOKEN_API][TOKEN_API_READY] = false;
            instance[TOKEN_API][TOKEN_API_HOST] = () => this;
            instance[TOKEN_API][TOKEN_API_STATE] = () => this.render();
            instance[TOKEN_API][TOKEN_API_PROPERTY] = (name, value, options = {}) => {
              const raw = this.getAttribute(name);
              const parsed = getValue(name, raw);
              if (parsed === value)
                return;
              if (options.reflect)
                updateAttribute(this, name, value);
              this.render();
            };
            for (const [key, type] of members) {
              let get, set;
              if (type === TYPE_FUNCTION) {
                get = () => instance[key].bind(instance);
              } else {
                get = () => instance[key];
                set = (value) => instance[key] = value;
              }
              Object.defineProperty(this, key, { get, set });
            }
            this.attachShadow({ mode: "open" });
          }
          static get observedAttributes() {
            return members.filter(([, type]) => type != TYPE_FUNCTION).map(([key]) => key);
          }
          attributeChangedCallback(name, prev, next) {
            instance[name] = getValue(name, next);
            if (!instance[TOKEN_API][TOKEN_API_READY])
              return;
            this.render();
          }
          connectedCallback() {
            update = sync(this, {});
            instance[TOKEN_LIFECYCLE_MOUNT] && instance[TOKEN_LIFECYCLE_MOUNT]();
            this.render();
            instance[TOKEN_LIFECYCLE_READY] && instance[TOKEN_LIFECYCLE_READY]();
            instance[TOKEN_API][TOKEN_API_READY] = true;
          }
          disconnectedCallback() {
            instance[TOKEN_LIFECYCLE_UNMOUNT] && instance[TOKEN_LIFECYCLE_UNMOUNT]();
          }
          render() {
            update(instance.attributes || {});
            const fn = instance[TOKEN_METHOD_RENDER];
            if (!fn)
              return;
            render(this.shadowRoot, () => {
              if (!styles)
                return fn();
              return html`<style>${styles}</style>${fn()}`;
            });
          }
        };
      };

      // dist/client/helpers/api.js
      var api = (target) => target["$api"];

      // dist/client/decorators/property.js
      function Property(options) {
        return function(target, propertyKey) {
          let value;
          const descriptor = Object.getOwnPropertyDescriptor(target, propertyKey) || {};
          const set = descriptor.set;
          descriptor.configurable = true;
          descriptor.get = function() {
            return value;
          };
          descriptor.set = function(input) {
            set && set.bind(this)(input);
            if (input === value)
              return;
            value = input;
            const api2 = api(this);
            if (!(api2 === null || api2 === void 0 ? void 0 : api2.ready))
              return;
            api2.property(propertyKey, input, options);
          };
          Object.defineProperty(target, propertyKey, descriptor);
        };
      }

      // <stdin>
      var __defProp = Object.defineProperty;
      var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
      var __decorateClass = (decorators, target, key, kind) => {
        var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
        for (var i = decorators.length - 1, decorator; i >= 0; i--)
          if (decorator = decorators[i])
            result = (kind ? decorator(target, key, result) : decorator(result)) || result;
        if (kind && result)
          __defProp(target, key, result);
        return result;
      };
      var AspectRatio = class {
        constructor() {
          this.value = 1;
        }
        get ratio() {
          if (typeof this.value === "number")
            return this.value;
          let [valueA, valueB] = `${this.value}`.split("/").map((item) => isNaN(item) ? NaN : parseFloat(item));
          valueB = valueB ?? 1;
          if (!isNaN(valueA + valueB))
            return valueA / valueB;
        }
        get style() {
          const ratio = this.ratio;
          if (!ratio)
            return;
          return `padding-top: ${100 / ratio}%`;
        }
        render() {
          return html`
              <div class="sizer" style="${this.style}" />
              <slot />
            `;
        }
      };
      AspectRatio.members = [["value"]];
      __decorateClass([
        Property()
      ], AspectRatio.prototype, "value", 2);
      define("plus-aspect-ratio", proxy(AspectRatio));
    </script>
    <style>
      div {
        background-color: #C5CAE9;
        padding: 1rem;
      }
    </style>
    <plus-aspect-ratio value="16/9">
      <div>
        This box will always be 16/9 (unless you put more stuff in it)
      </div>
    </plus-aspect-ratio>
  </body>
</html>
